<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Edge Master: Invincible AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { 
            font-family: 'Inter', system-ui, sans-serif; 
            color: #e2e8f0; 
            user-select: none; 
            transition: background-color 1.5s ease;
            -webkit-tap-highlight-color: transparent;
        }
        
        /* Modern Canvas Container */
        .canvas-container {
            background: rgba(15, 23, 42, 0.6); 
            border-radius: 24px;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5), 0 0 0 1px rgba(255,255,255,0.1);
            position: relative;
            overflow: hidden;
            transition: box-shadow 1s ease;
            /* Mobile Aspect Ratio */
            min-height: 350px;
        }

        canvas { 
            cursor: crosshair; 
            touch-action: none; 
        }
        
        /* Neon Thinking Bar */
        .thinking-bar-bg { 
            width: 100%; height: 6px; background: rgba(30, 41, 59, 0.5); border-radius: 99px; overflow: hidden; margin-top: 16px; 
            border: 1px solid rgba(255,255,255,0.1);
        }
        .thinking-bar { 
            height: 100%; 
            background: linear-gradient(90deg, #f43f5e, #a855f7, #3b82f6); 
            background-size: 200% 100%;
            width: 0%; 
            transition: width 0.2s ease-out; 
            animation: gradient-move 2s linear infinite;
            box-shadow: 0 0 15px rgba(168, 85, 247, 0.6);
        }
        @keyframes gradient-move { 0% { background-position: 100% 0; } 100% { background-position: -100% 0; } }
        
        .panel-card { 
            background: rgba(30, 41, 59, 0.7); 
            backdrop-filter: blur(12px); 
            padding: 24px; 
            border-radius: 24px; 
            border: 1px solid rgba(255,255,255,0.1); 
            transition: all 0.5s ease;
        }
        
        /* Pulse Animation */
        @keyframes pulse-ring { 0% { box-shadow: 0 0 0 0 rgba(168, 85, 247, 0.4); } 70% { box-shadow: 0 0 0 12px rgba(168, 85, 247, 0); } 100% { box-shadow: 0 0 0 0 rgba(168, 85, 247, 0); } }
        .ai-active { animation: pulse-ring 2s infinite; border-color: #a855f7; }

        /* Background Themes */
        .theme-alice { background-color: #020617; background-image: radial-gradient(circle at 50% 0%, #1e1b4b 0%, #020617 60%); }
        .theme-bob { background-color: #022c22; background-image: radial-gradient(circle at 50% 0%, #064e3b 0%, #022c22 70%); }
    </style>
</head>
<!-- Removed h-screen to allow scrolling on mobile, added min-h-screen -->
<body id="mainBody" class="min-h-screen flex flex-col items-center justify-center p-4 lg:p-8 gap-6 theme-alice relative overflow-y-auto lg:overflow-hidden">

    <!-- Header -->
    <div class="w-full max-w-7xl flex flex-col md:flex-row justify-between items-end gap-4 z-10 shrink-0">
        <div>
            <h1 class="text-4xl md:text-6xl font-black text-white tracking-tighter mb-1 drop-shadow-lg">EDGE <span class="text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-600">MASTER</span></h1>
            <p class="text-slate-400 text-xs md:text-sm font-medium tracking-[0.2em] uppercase">Invincible Isolation Engine</p>
        </div>

        <!-- Hidden Stats -->
        <div class="hidden gap-4">
            <div id="visit-count"></div>
            <div id="win-rate"></div>
        </div>
    </div>

    <!-- Main Layout: flex-col-reverse for Mobile (Game Top, Settings Bottom) -->
    <div class="flex flex-col-reverse lg:flex-row gap-6 w-full max-w-7xl flex-1 min-h-0 relative z-10">
        
        <!-- Sidebar (Controls) -->
        <div class="w-full lg:w-80 flex flex-col gap-4 z-10 shrink-0">
            
            <!-- AI Status (Visible on Mobile) -->
            <div class="panel-card flex-1 flex flex-col justify-center items-center text-center relative transition-colors duration-1000 order-1 lg:order-2" id="status-panel">
                <div id="ai-avatar" class="w-16 h-16 md:w-20 md:h-20 rounded-full bg-gradient-to-br from-slate-800 to-slate-900 border-2 border-slate-700 flex items-center justify-center mb-4 relative shadow-2xl transition-all duration-500">
                    <div class="text-3xl md:text-4xl">ü§ñ</div>
                    <div id="ai-pulse" class="absolute inset-0 rounded-full border-2 border-purple-500 opacity-0"></div>
                </div>
                
                <div class="text-lg font-bold text-white mb-1" id="turn-text">Your Turn</div>
                <div class="text-xs text-slate-400 font-medium" id="sub-text">Tap to cut a connection</div>
                
                <!-- Thinking Bar -->
                <div id="thinking-ui" class="w-full mt-4 md:mt-6 opacity-0 transition-opacity duration-300">
                    <div class="flex justify-between text-[10px] text-purple-300 font-bold tracking-widest mb-2">
                        <span>CALCULATING</span>
                        <span id="progress-text">0%</span>
                    </div>
                    <div class="thinking-bar-bg">
                        <div id="thinking-bar" class="thinking-bar"></div>
                    </div>
                </div>
            </div>

            <!-- Controls (Bottom on Mobile) -->
            <div class="panel-card flex flex-col gap-6 order-2 lg:order-1">
                <div>
                    <div class="flex justify-between items-center mb-3">
                        <label class="text-xs font-bold text-slate-400 uppercase tracking-widest">Map Size</label>
                        <span class="text-xs font-mono text-purple-400 bg-purple-400/10 px-2 py-1 rounded">N = <span id="n-val">9</span></span>
                    </div>
                    <input type="range" id="nRange" min="6" max="10" value="9" class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-purple-500 hover:accent-purple-400 transition-all">
                    <div class="flex justify-between text-[10px] text-slate-600 mt-2 font-mono">
                        <span>NORMAL (6)</span>
                        <span>HUGE (10)</span>
                    </div>
                </div>

                <input type="hidden" id="simBudget" value="100000">

                <div class="flex items-center gap-3 bg-black/20 p-3 rounded-xl border border-white/5">
                    <input type="checkbox" id="aiVsAi" class="w-5 h-5 text-purple-600 rounded bg-slate-700 border-slate-600 focus:ring-purple-500 focus:ring-offset-0 cursor-pointer">
                    <label for="aiVsAi" class="text-sm font-semibold text-slate-300 cursor-pointer select-none">
                        AI plays against itself
                    </label>
                </div>

                <button id="resetBtn" class="group w-full py-4 bg-white text-slate-900 font-black rounded-xl text-sm transition-all shadow-[0_0_20px_rgba(255,255,255,0.1)] hover:shadow-[0_0_25px_rgba(255,255,255,0.3)] hover:scale-[1.02] active:scale-95 flex items-center justify-center gap-2">
                    <span class="group-hover:rotate-180 transition-transform duration-500">‚Üª</span> START NEW GAME
                </button>
            </div>
            
            <button id="clearBrain" class="text-[10px] text-slate-600 hover:text-slate-400 transition-colors text-center pb-2 order-3">Reset AI Memory</button>
        </div>

        <!-- Canvas -->
        <div class="flex-1 canvas-container flex items-center justify-center h-[400px] lg:h-auto w-full" id="game-container">
            <canvas id="gameCanvas" class="w-full h-full"></canvas>
            
            <!-- Result Overlay -->
            <div id="overlay" class="absolute inset-0 bg-slate-900/95 backdrop-blur-xl flex flex-col items-center justify-center z-20 opacity-0 pointer-events-none transition-all duration-500 scale-95">
                <div id="overlay-icon" class="text-6xl mb-4">üèÜ</div>
                <h2 id="overlayTitle" class="text-4xl md:text-7xl font-black text-white mb-4 tracking-tighter drop-shadow-2xl text-center">YOU WON</h2>
                <p id="overlaySub" class="text-slate-400 text-base md:text-lg font-medium mb-10 tracking-wide">You outsmarted the AI.</p>
                <button id="playAgainBtn" class="px-12 py-5 bg-gradient-to-r from-purple-600 to-pink-600 text-white font-black rounded-full shadow-2xl hover:scale-105 transition-transform active:scale-95 text-lg tracking-wide">
                    PLAY AGAIN
                </button>
            </div>
        </div>
    </div>

    <!-- Footer Reference -->
    <div class="w-full text-center py-4 z-0 pointer-events-none">
        <p class="text-[10px] text-slate-600 font-medium pointer-events-auto">
            This game is based on the question at <a href="https://puzzling.stackexchange.com/questions/131519/edge-removal-game" target="_blank" rel="noopener noreferrer" class="text-slate-500 hover:text-purple-400 transition-colors underline decoration-slate-700 underline-offset-2">StackExchange</a>
        </p>
    </div>

<script>
{ // Block Scope

// --- GHOST BRAIN (Memory) ---
class GhostBrain {
    constructor() {
        this.memory = {}; 
        this.load();
    }
    load() {
        try {
            const data = localStorage.getItem('edge_master_brain_v2');
            if (data) this.memory = JSON.parse(data);
        } catch (e) { }
    }
    save() {
        try {
            localStorage.setItem('edge_master_brain_v2', JSON.stringify(this.memory));
        } catch (e) { }
    }
    getValue(key) {
        const entry = this.memory[key];
        if (!entry || entry.N === 0) return null; 
        return entry.W / entry.N;
    }
    update(key, z) {
        if (!this.memory[key]) this.memory[key] = { N: 0, W: 0 };
        const entry = this.memory[key];
        entry.N++;
        entry.W += z;
    }
    clear() {
        this.memory = {};
        localStorage.removeItem('edge_master_brain_v2');
    }
}
const brain = new GhostBrain();

// --- GAME LOGIC ---
class GraphState {
    constructor(n, activeMask = null, degrees = null, edges = null) {
        this.n = n;
        if (activeMask === null) {
            this.edges = [];
            let idx = 0;
            for (let u = 0; u < n; u++) {
                for (let v = u + 1; v < n; v++) {
                    this.edges.push({ u, v, idx });
                    idx++;
                }
            }
            this.num_edges = idx;
            this.activeMask = (1n << BigInt(this.num_edges)) - 1n;
            this.degrees = new Int8Array(n).fill(n - 1);
        } else {
            this.edges = edges;
            this.activeMask = activeMask;
            this.degrees = new Int8Array(degrees);
            this.num_edges = edges.length;
        }
    }
    clone() {
        return new GraphState(this.n, this.activeMask, this.degrees, this.edges);
    }
    getHash(turn) {
        return `n${this.n}_${this.activeMask.toString()}_t${turn}`;
    }
    getLegalMoves() {
        const moves = [];
        for (let i = 0; i < this.num_edges; i++) {
            if ((this.activeMask >> BigInt(i)) & 1n) {
                const e = this.edges[i];
                if (this.degrees[e.u] === 1 || this.degrees[e.v] === 1) return [i]; 
                moves.push(i);
            }
        }
        return moves;
    }
    doMove(moveIdx) {
        if (!((this.activeMask >> BigInt(moveIdx)) & 1n)) return false;
        this.activeMask &= ~(1n << BigInt(moveIdx));
        const e = this.edges[moveIdx];
        this.degrees[e.u]--;
        this.degrees[e.v]--;
        return true;
    }
    isTerminal() {
        for(let i=0; i<this.n; i++) if(this.degrees[i] === 0) return true;
        return false;
    }
}

// --- MCTS NODE ---
class MCTSNode {
    constructor(move = null, parent = null, state = null, turn = null) {
        this.move = move;
        this.parent = parent;
        this.children = new Map();
        this.wins = 0; 
        this.visits = 0;
        this.depth = parent ? parent.depth + 1 : 0;
        this.isExpanded = false;
        
        // Lazy load
        this.legalMoves = state ? state.getLegalMoves() : [];
        if (state) this.calculatePriors(state);

        if (parent === null) this.playerJustMoved = 1 - turn; 
        else this.playerJustMoved = 1 - parent.playerJustMoved;
    }

    calculatePriors(state) {
        this.legalMoves = state.getLegalMoves();
        if (this.legalMoves.length === 0) return;
        let sumScores = 0;
        this.movePriors = {}; 
        for (const m of this.legalMoves) {
            const e = state.edges[m];
            const score = state.degrees[e.u] + state.degrees[e.v];
            const w = Math.pow(score, 2); 
            this.movePriors[m] = w;
            sumScores += w;
        }
        if (sumScores <= 0) {
            const p = 1.0 / this.legalMoves.length;
            for (const m of this.legalMoves) this.movePriors[m] = p;
            return;
        }
        for (const m of this.legalMoves) this.movePriors[m] /= sumScores;
    }

    selectChild() {
        let best = null;
        let bestScore = -Infinity;
        const cpuct = 1.25; 
        for (const child of this.children.values()) {
            let Q = 0.5; 
            if (child.visits > 0) Q = child.wins / child.visits;
            const P = this.movePriors[child.move] || 0;
            const U = cpuct * P * (Math.sqrt(this.visits) / (1 + child.visits));
            const score = (1.0 - Q) + U;
            if (score > bestScore) { bestScore = score; best = child; }
        }
        return best;
    }

    expand() {
        if (!this.legalMoves) return;
        for (const m of this.legalMoves) {
            if (!this.children.has(m)) {
                const child = new MCTSNode(m, this, null);
                child.prior = this.movePriors[m];
                this.children.set(m, child);
            }
        }
        this.isExpanded = true;
    }
}

// --- AI ENGINE ---
class AIEngine {
    constructor(state, startTurn) {
        this.root = new MCTSNode(null, null, state, startTurn); 
        this.rootState = state.clone();
        this.currentTurn = startTurn;
    }

    advanceTree(moveIdx) {
        this.currentTurn = 1 - this.currentTurn;
        if (this.root.children.has(moveIdx)) {
            this.root = this.root.children.get(moveIdx);
            this.root.parent = null; 
            this.rootState.doMove(moveIdx);
        } else {
            this.rootState.doMove(moveIdx);
            this.root = new MCTSNode(null, null, this.rootState, this.currentTurn);
        }
    }

    evaluate(state, turn) {
        if (state.isTerminal()) return 0.0; 
        const hash = state.getHash(turn);
        const storedVal = brain.getValue(hash);
        if (storedVal !== null) return storedVal; 

        let tempState = state.clone();
        let simTurn = turn;
        let movesCount = 0;
        while (true) {
            const moves = tempState.getLegalMoves();
            if (moves.length === 0) break; 
            if (moves.length === 1 && tempState.degrees[tempState.edges[moves[0]].u] === 1) return (simTurn === turn) ? 1.0 : 0.0;
            
            let candidates = moves;
            // Rollout Heuristic
            if (moves.length > 1) {
                 const safe = moves.filter(m => {
                     const e = tempState.edges[m];
                     return tempState.degrees[e.u] > 2 && tempState.degrees[e.v] > 2;
                 });
                 if (safe.length > 0) candidates = safe;
            }
            const m = candidates[Math.floor(Math.random() * candidates.length)];
            tempState.doMove(m);
            if (tempState.isTerminal()) return (simTurn === turn) ? 1.0 : 0.0;
            simTurn = 1 - simTurn;
            movesCount++;
            if (movesCount > 150) return 0.5; 
        }
        return 0.5;
    }

    run(budget, gameId, updateCallback) {
        return new Promise(resolve => {
            let iterations = 0;
            const batch = 300;
            const loop = () => {
                if (game.id !== gameId) return;
                const end = Math.min(iterations + batch, budget);
                for (; iterations < end; iterations++) {
                    let node = this.root;
                    let state = this.rootState.clone();
                    let turn = this.currentTurn; 
                    while (node.isExpanded && node.children.size > 0) {
                        node = node.selectChild();
                        state.doMove(node.move);
                        turn = 1 - turn; 
                    }
                    if (!state.isTerminal()) {
                        if (!node.isExpanded) {
                            node.calculatePriors(state);
                            node.expand();
                        }
                    }
                    let v = this.evaluate(state, turn);
                    let currNode = node;
                    while (currNode !== null) {
                        currNode.visits++;
                        currNode.wins += v;
                        v = 1.0 - v; 
                        currNode = currNode.parent;
                    }
                }
                if (iterations % 600 === 0 && updateCallback) updateCallback(iterations / budget);
                if (iterations < budget) {
                    if (game.id === gameId) requestAnimationFrame(loop);
                } else {
                    resolve(this.root);
                }
            };
            loop();
        });
    }
}

// --- UI & INTERACTION ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const ui = {
    body: document.getElementById('mainBody'),
    nRange: document.getElementById('nRange'),
    nVal: document.getElementById('n-val'),
    simLevel: document.getElementById('simBudget'),
    
    aiAvatar: document.getElementById('ai-avatar'),
    aiPulse: document.getElementById('ai-pulse'),
    turnText: document.getElementById('turn-text'),
    subText: document.getElementById('sub-text'),
    statusPanel: document.getElementById('status-panel'),
    gameContainer: document.getElementById('game-container'),
    
    thinkingUI: document.getElementById('thinking-ui'),
    bar: document.getElementById('thinking-bar'),
    progress: document.getElementById('progress-text'),
    
    overlay: document.getElementById('overlay'),
    overlayTitle: document.getElementById('overlayTitle'),
    overlaySub: document.getElementById('overlaySub'),
    overlayIcon: document.getElementById('overlay-icon'),
    
    aiVsAi: document.getElementById('aiVsAi')
};

let game = {
    id: 0, 
    n: 9,
    engine: null,
    nodes: [],
    turn: 0,
    gameOver: false,
    hoveredEdge: null,
    history: [],
    animatingEdges: [] // Stores visual fade out effects
};

// Canvas Resizing with Pixel Ratio Support
function resizeCanvas() {
    const parent = canvas.parentElement;
    const dpr = window.devicePixelRatio || 1;
    const rect = parent.getBoundingClientRect();
    
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    // Keep CSS size matched
    // No explicit style width needed if container handles it, 
    // but useful for clarity.
    
    ctx.scale(dpr, dpr);
    
    if(game.nodes.length > 0) {
        initNodePositions();
        draw(); // Single draw call
    }
}
window.addEventListener('resize', resizeCanvas);

function initNodePositions() {
    game.nodes = [];
    const rect = canvas.getBoundingClientRect();
    const width = rect.width;
    const height = rect.height;
    
    const r = Math.min(width, height) * 0.35;
    const cx = width/2;
    const cy = height/2;
    
    for(let i=0; i<game.n; i++) {
        const a = (i * 2 * Math.PI / game.n) - Math.PI/2;
        game.nodes.push({x: cx + Math.cos(a)*r, y: cy + Math.sin(a)*r});
    }
}

function updateTheme(turn) {
    if (turn === 0) { // Alice (AI)
        ui.body.className = "h-screen flex flex-col items-center justify-center p-4 lg:p-8 gap-6 theme-alice relative overflow-y-auto lg:overflow-hidden";
        ui.gameContainer.style.boxShadow = "inset 0 0 40px rgba(168, 85, 247, 0.1)";
    } else { // Bob (Player)
        ui.body.className = "h-screen flex flex-col items-center justify-center p-4 lg:p-8 gap-6 theme-bob relative overflow-y-auto lg:overflow-hidden";
        ui.gameContainer.style.boxShadow = "inset 0 0 40px rgba(16, 185, 129, 0.1)";
    }
}

const THINKING_PHRASES = [
    "Analyzing Strategy...",
    "Calculating Odds...",
    "Checking Traps...",
    "Simulating Future...",
    "Scanning Weaknesses..."
];

function setAIState(state) {
    if (state === 'thinking') {
        updateTheme(0);
        ui.aiPulse.classList.add('animate-ping', 'opacity-100');
        ui.aiAvatar.classList.add('border-purple-500', 'shadow-[0_0_30px_rgba(168,85,247,0.4)]');
        ui.aiAvatar.classList.remove('border-emerald-500');
        
        ui.turnText.innerText = "AI is Thinking";
        ui.turnText.className = "text-lg font-bold text-purple-400 mb-1";
        ui.subText.innerText = THINKING_PHRASES[Math.floor(Math.random() * THINKING_PHRASES.length)];
        ui.thinkingUI.classList.remove('opacity-0');
        canvas.style.cursor = "wait";
    } else {
        updateTheme(1);
        ui.aiPulse.classList.remove('animate-ping', 'opacity-100');
        ui.aiAvatar.classList.remove('border-purple-500', 'shadow-[0_0_30px_rgba(168,85,247,0.4)]');
        ui.aiAvatar.classList.add('border-emerald-500');
        
        ui.turnText.innerText = "Your Turn";
        ui.turnText.className = "text-lg font-bold text-emerald-400 mb-1";
        ui.subText.innerText = "Tap a connection to cut";
        ui.thinkingUI.classList.add('opacity-0');
        canvas.style.cursor = "crosshair";
    }
}

function startGame() {
    game.id++;
    game.n = parseInt(ui.nRange.value);
    const startState = new GraphState(game.n);
    game.engine = new AIEngine(startState, 0); 
    game.history = []; 
    game.animatingEdges = [];
    game.turn = 0;
    game.gameOver = false;
    
    ui.overlay.classList.add('opacity-0', 'pointer-events-none', 'scale-95');
    
    initNodePositions();
    drawLoop(); // Start loop
    
    setTimeout(() => runAITurn(game.id), 800);
}

async function runAITurn(sessionId) {
    if(game.gameOver || game.id !== sessionId) return;

    setAIState('thinking');
    const budget = 100000; 
    
    await game.engine.run(budget, sessionId, (pct) => {
        ui.bar.style.width = `${pct * 100}%`;
        ui.progress.innerText = `${Math.round(pct*100)}%`;
    });

    if (game.id !== sessionId) return; 

    let bestChild = null;
    let maxVisits = -1;
    
    if (game.engine.root.children.size === 0) {
        const moves = game.engine.rootState.getLegalMoves();
        if (moves.length > 0) applyMove(moves[0]);
        return;
    }

    for (const child of game.engine.root.children.values()) {
        if (child.visits > maxVisits) {
            maxVisits = child.visits;
            bestChild = child;
        }
    }

    game.history.push({
        hash: game.engine.rootState.getHash(game.turn),
        player: game.turn
    });

    applyMove(bestChild.move);
}

function applyMove(moveIdx) {
    // Add visual effect
    const edge = game.engine.rootState.edges[moveIdx];
    game.animatingEdges.push({
        u: edge.u,
        v: edge.v,
        color: game.turn === 0 ? '#a855f7' : '#10b981', // Purple vs Emerald
        dash: game.turn === 0 ? [5, 5] : [10, 5],
        startTime: performance.now(),
        duration: 1500
    });

    game.engine.advanceTree(moveIdx);
    
    if (game.engine.rootState.isTerminal()) {
        endGame(game.turn);
        return;
    }

    game.turn = 1 - game.turn;
    
    if (game.turn === 0 || ui.aiVsAi.checked) {
        setTimeout(() => runAITurn(game.id), 200);
    } else {
        setAIState('waiting');
    }
}

function endGame(winner) {
    game.gameOver = true;
    ui.overlay.classList.remove('opacity-0', 'pointer-events-none', 'scale-95');
    
    game.history.forEach(step => {
        const val = (step.player === winner) ? 1.0 : 0.0;
        brain.update(step.hash, val);
    });
    brain.save();

    if (winner === 0) { 
        ui.overlayTitle.innerText = "DEFEATED";
        ui.overlaySub.innerText = "The AI outsmarted you.";
        ui.overlayTitle.className = "text-5xl lg:text-7xl font-black text-red-500 mb-4 tracking-tighter drop-shadow-2xl text-center";
        ui.overlayIcon.innerText = "üíÄ";
    } else { 
        ui.overlayTitle.innerText = "LEGENDARY VICTORY";
        ui.overlaySub.innerText = "You defeated the Invincible AI!";
        ui.overlayTitle.className = "text-5xl lg:text-7xl font-black text-emerald-400 mb-4 tracking-tighter drop-shadow-2xl text-center";
        ui.overlayIcon.innerText = "üèÜ";
    }
}

// Interaction
function getEdgeAt(x, y, tolerance = 30) {
    let best = null, minDist = tolerance; 
    const state = game.engine.rootState;
    // Input x, y are CSS pixels relative to canvas
    
    for (let i=0; i<state.num_edges; i++) {
        if (!((state.activeMask >> BigInt(i)) & 1n)) continue;
        const e = state.edges[i];
        const n1 = game.nodes[e.u], n2 = game.nodes[e.v];
        
        const A=x-n1.x, B=y-n1.y, C=n2.x-n1.x, D=n2.y-n1.y;
        const dot = A*C + B*D, len_sq = C*C + D*D;
        const t = len_sq ? Math.max(0, Math.min(1, dot/len_sq)) : 0;
        const dist = Math.hypot(x - (n1.x + t*C), y - (n1.y + t*D));
        if (dist < minDist) { minDist = dist; best = i; }
    }
    return best;
}

// TOUCH EVENTS
canvas.addEventListener('touchstart', e => {
    e.preventDefault(); // Stop scroll
    const rect = canvas.getBoundingClientRect();
    const touch = e.touches[0];
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;
    
    const move = getEdgeAt(x, y, 60); // Higher tolerance for touch
    game.hoveredEdge = move;
    draw(); // Draw highlight
}, {passive: false});

canvas.addEventListener('touchmove', e => {
    e.preventDefault(); // Stop scroll/zoom
    if (game.turn === 0 || game.gameOver) return;
    
    const rect = canvas.getBoundingClientRect();
    const touch = e.touches[0];
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;
    
    const move = getEdgeAt(x, y, 60);
    if (move !== game.hoveredEdge) {
        game.hoveredEdge = move;
        draw();
    }
}, {passive: false});

canvas.addEventListener('touchend', e => {
    e.preventDefault();
    if (game.gameOver || game.turn === 0) return;
    
    if (game.hoveredEdge !== null) {
        applyMove(game.hoveredEdge);
        game.hoveredEdge = null;
    }
}, {passive: false});

// MOUSE EVENTS
canvas.addEventListener('mousemove', e => {
    if (game.turn === 0 || game.gameOver) return;
    const r = canvas.getBoundingClientRect();
    const move = getEdgeAt(e.clientX - r.left, e.clientY - r.top);
    game.hoveredEdge = move;
    canvas.style.cursor = move !== null ? 'pointer' : 'crosshair';
});

canvas.addEventListener('click', e => {
    if (game.gameOver || game.turn === 0) return;
    if (game.hoveredEdge !== null) {
        applyMove(game.hoveredEdge);
        game.hoveredEdge = null;
    }
});

// ANIMATION LOOP
function drawLoop() {
    draw();
    if (!game.gameOver) {
        requestAnimationFrame(drawLoop);
    }
}

function draw() {
    const width = canvas.width / (window.devicePixelRatio||1);
    const height = canvas.height / (window.devicePixelRatio||1);
    ctx.clearRect(0,0, width, height);
    
    if (!game.engine) return;
    const state = game.engine.rootState;
    const now = performance.now();

    // 1. Draw Active Edges
    for(let i=0; i<state.num_edges; i++) {
        if(!((state.activeMask >> BigInt(i)) & 1n)) continue;
        const e = state.edges[i];
        const n1 = game.nodes[e.u], n2 = game.nodes[e.v];
        
        ctx.beginPath();
        ctx.moveTo(n1.x, n1.y); ctx.lineTo(n2.x, n2.y);
        
        if (i === game.hoveredEdge && game.turn === 1) {
            ctx.lineWidth = 6; 
            ctx.strokeStyle = '#34d399'; // Emerald Highlight
            ctx.shadowColor = '#34d399'; ctx.shadowBlur = 15;
        } else {
            ctx.lineWidth = 2; 
            ctx.strokeStyle = '#334155'; 
            ctx.shadowBlur = 0;
        }
        ctx.setLineDash([]);
        ctx.stroke();
        ctx.shadowBlur = 0;
    }

    // 2. Draw Ghost (Animating) Edges
    game.animatingEdges = game.animatingEdges.filter(anim => (now - anim.startTime) < anim.duration);
    
    for(const anim of game.animatingEdges) {
        const progress = (now - anim.startTime) / anim.duration; // 0 to 1
        const opacity = 1.0 - Math.pow(progress, 3); // Slow fade out
        
        const n1 = game.nodes[anim.u];
        const n2 = game.nodes[anim.v];
        
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(n1.x, n1.y); ctx.lineTo(n2.x, n2.y);
        ctx.lineWidth = 4;
        ctx.strokeStyle = anim.color;
        ctx.globalAlpha = opacity;
        ctx.setLineDash(anim.dash);
        // Animate Dash offset
        ctx.lineDashOffset = -progress * 50;
        ctx.stroke();
        ctx.restore();
    }

    // 3. Draw Nodes
    game.nodes.forEach((pos, i) => {
        const deg = state.degrees[i];
        ctx.beginPath();
        
        // Responsive Radius
        const nodeR = Math.max(12, width * 0.035); 
        ctx.arc(pos.x, pos.y, nodeR, 0, Math.PI*2);
        
        if(deg===1) {
            ctx.fillStyle='#ef4444'; ctx.shadowColor='#ef4444'; ctx.shadowBlur=20;
        } else if(deg===2) {
            ctx.fillStyle='#f59e0b'; ctx.shadowColor='#f59e0b'; ctx.shadowBlur=10;
        } else {
            ctx.fillStyle='#3b82f6'; ctx.shadowBlur=0;
        }
        
        ctx.fill();
        ctx.strokeStyle='#0f172a'; ctx.lineWidth=4; ctx.stroke();
        ctx.shadowBlur=0;
        
        ctx.fillStyle='white'; ctx.font=`bold ${nodeR*0.7}px Inter`;
        ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(deg, pos.x, pos.y);
    });
}

// Global scope
window.startGame = startGame;

// Safe Event Listeners
const resetBtn = document.getElementById('resetBtn');
if (resetBtn) resetBtn.onclick = startGame;

const clearBrain = document.getElementById('clearBrain');
if (clearBrain) clearBrain.onclick = () => {
    if(confirm('Do you want to clear all learned AI strategies?')) brain.clear();
};

const nRange = document.getElementById('nRange');
if (nRange) nRange.oninput = (e) => {
    document.getElementById('n-val').innerText = e.target.value;
    startGame();
};

const playAgainBtn = document.getElementById('playAgainBtn');
if (playAgainBtn) playAgainBtn.onclick = startGame;

// Init
resizeCanvas();
setTimeout(startGame, 100);

} // Scope End
</script>
</body>
</html>
