<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Edge Master: Mobile AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Inter:wght@400;600;900&display=swap');

        :root {
            --alice-bg: #0f172a;
            --bob-bg: #022c22;
            --accent: #a855f7;
        }

        body { 
            font-family: 'Inter', system-ui, sans-serif; 
            background-color: var(--alice-bg);
            color: #e2e8f0; 
            overflow: hidden; /* Prevent scrolling */
            touch-action: none; /* Prevent default browser gestures */
            user-select: none;
            -webkit-user-select: none;
            transition: background-color 1s ease;
        }

        /* Full Screen Canvas */
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            cursor: grab;
        }
        #gameCanvas:active { cursor: grabbing; }

        /* Floating UI Elements */
        .hud-panel {
            position: absolute;
            z-index: 10;
            backdrop-filter: blur(8px);
            background: rgba(15, 23, 42, 0.85);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 16px;
            padding: 12px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        /* Top Status Bar */
        .top-bar {
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 12px;
            white-space: nowrap;
            padding: 8px 20px;
            border-radius: 99px;
            max-width: 90%;
        }

        /* Minimal Thinking Line */
        .thinking-line {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, #f43f5e, #a855f7, #3b82f6);
            background-size: 200% 100%;
            animation: gradient-move 1s linear infinite;
            z-index: 20;
            opacity: 0;
            transition: opacity 0.3s;
        }
        @keyframes gradient-move { 0% { background-position: 100% 0; } 100% { background-position: -100% 0; } }

        /* Settings Toggle (Bottom Right) */
        .fab-btn {
            position: absolute;
            bottom: 24px;
            right: 24px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: #1e293b;
            color: white;
            border: 1px solid rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            z-index: 20;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            transition: transform 0.2s;
        }
        .fab-btn:active { transform: scale(0.9); }

        /* Settings Modal Overlay */
        #settings-modal {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: #1e293b;
            border-top: 1px solid rgba(255,255,255,0.1);
            border-radius: 24px 24px 0 0;
            padding: 24px;
            transform: translateY(110%);
            transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            z-index: 50;
            box-shadow: 0 -10px 40px rgba(0,0,0,0.5);
        }
        #settings-modal.active { transform: translateY(0); }
        .modal-backdrop {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.6);
            z-index: 40;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        .modal-backdrop.active { opacity: 1; pointer-events: auto; }

        /* Selection Screen */
        #selection-screen {
            position: absolute;
            inset: 0;
            background: #020617;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s ease;
        }

        /* Overlay Messages */
        #message-overlay {
            pointer-events: none;
            opacity: 0;
            transform: scale(0.9);
            transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        #message-overlay.visible { opacity: 1; transform: scale(1); pointer-events: auto; }

        /* Range Slider Styling */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 24px;
            width: 24px;
            border-radius: 50%;
            background: #a855f7;
            cursor: pointer;
            margin-top: -10px;
            box-shadow: 0 0 10px rgba(168,85,247,0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #334155;
            border-radius: 2px;
        }
    </style>
</head>
<body>

    <!-- Thinking Indicator -->
    <div id="thinking-line" class="thinking-line"></div>

    <!-- Canvas Layer -->
    <canvas id="gameCanvas"></canvas>

    <!-- Top Status HUD -->
    <div class="hud-panel top-bar" id="status-hud">
        <div id="turn-indicator" class="w-3 h-3 rounded-full bg-emerald-500 animate-pulse"></div>
        <div class="flex flex-col">
            <span id="status-text" class="text-xs font-bold uppercase tracking-widest text-white">YOUR TURN</span>
            <span id="hint-text" class="text-[10px] text-slate-400 font-mono">Double tap to cut</span>
        </div>
    </div>

    <!-- Bottom Right Settings Button -->
    <button class="fab-btn" onclick="toggleSettings()">
        ‚öôÔ∏è
    </button>

    <!-- Modal Backdrop -->
    <div id="modal-backdrop" class="modal-backdrop" onclick="toggleSettings()"></div>

    <!-- Settings Modal -->
    <div id="settings-modal">
        <div class="w-12 h-1 bg-slate-600 rounded-full mx-auto mb-6"></div>
        
        <div class="space-y-6">
            <!-- Map Size -->
            <div>
                <div class="flex justify-between items-center mb-2">
                    <label class="text-sm font-bold text-slate-300">Map Size (N)</label>
                    <span id="n-display" class="text-xs font-mono bg-slate-700 px-2 py-1 rounded text-white">9</span>
                </div>
                <input type="range" id="nRange" min="4" max="12" value="9" oninput="updateN(this.value)">
            </div>

            <!-- Controls -->
            <div class="grid grid-cols-2 gap-3">
                <button onclick="changePlayer()" class="p-4 bg-slate-800 border border-slate-700 rounded-xl text-slate-300 font-bold text-sm hover:bg-slate-700 active:scale-95 transition-all">
                    üë§ Change Role
                </button>
                <button onclick="restartGame()" class="p-4 bg-white text-slate-900 rounded-xl font-black text-sm hover:bg-slate-200 active:scale-95 transition-all">
                    ‚Üª New Game
                </button>
            </div>

            <div class="pt-4 border-t border-slate-700">
                <p class="text-[10px] text-slate-500 text-center">
                    Pinch to Zoom ‚Ä¢ Drag to Pan ‚Ä¢ Double Tap Edge
                </p>
            </div>
        </div>
    </div>

    <!-- Victory/Defeat Overlay -->
    <div id="message-overlay" class="absolute inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-md p-6">
        <div class="text-center max-w-sm">
            <div id="msg-icon" class="text-6xl mb-4">üèÜ</div>
            <h1 id="msg-title" class="text-4xl font-black text-white mb-2 tracking-tighter">VICTORY</h1>
            <p id="msg-sub" class="text-slate-400 text-sm mb-8">You outsmarted the machine.</p>
            <button onclick="restartGame()" class="w-full py-4 bg-gradient-to-r from-purple-600 to-pink-600 rounded-full font-bold text-white shadow-lg active:scale-95 transition-transform">
                PLAY AGAIN
            </button>
        </div>
    </div>

    <!-- Character Selection Screen -->
    <div id="selection-screen">
        <h1 class="text-5xl font-black text-white tracking-tighter mb-8 drop-shadow-lg text-center">EDGE <span class="text-purple-500">MASTER</span></h1>
        
        <div class="flex flex-col gap-4 w-full max-w-xs px-6">
            <button onclick="startGameAs(0)" class="relative p-6 bg-slate-800/80 border border-slate-600 rounded-2xl flex items-center gap-4 hover:border-purple-500 transition-all active:scale-95">
                <div class="text-4xl">üë©‚Äçü¶∞</div>
                <div class="text-left">
                    <div class="font-black text-white">ALICE</div>
                    <div class="text-[10px] text-purple-400 font-bold uppercase">Starts First</div>
                </div>
            </button>
            
            <button onclick="startGameAs(1)" class="relative p-6 bg-slate-800/80 border border-slate-600 rounded-2xl flex items-center gap-4 hover:border-emerald-500 transition-all active:scale-95">
                <div class="text-4xl">üßî</div>
                <div class="text-left">
                    <div class="font-black text-white">BOB</div>
                    <div class="text-[10px] text-emerald-400 font-bold uppercase">Starts Second</div>
                </div>
            </button>
        </div>
    </div>

<script>
/* =========================
   SMART CORE (ML + MCTS)
   Drop-in replacement script
   ========================= */

/** ---------- Ghost Brain ---------- **/
class GhostBrain {
  constructor(key = "edge_mobile_brain_v2") { this.key = key; this.mem = {}; this.load(); }
  load(){ try{ const d = localStorage.getItem(this.key); if(d) this.mem = JSON.parse(d);}catch(e){} }
  save(){ try{ localStorage.setItem(this.key, JSON.stringify(this.mem)); }catch(e){} }
  get(k){ const e = this.mem[k]; if(!e || !e.N) return null; return e.W / e.N; }
  update(k, z){ if(!this.mem[k]) this.mem[k]={N:0,W:0}; const e=this.mem[k]; e.N++; e.W += z; }
  clear(){ this.mem={}; try{ localStorage.removeItem(this.key);}catch(e){} }
}
const brain = new GhostBrain();

/** ---------- ML Value Models (Logistic Regression) ---------- **/
const MLModels = {
  baseUrl: "./models",
  models: new Map(), // n -> { w: [] }

  async loadForN(n){
    if(this.models.has(n)) return this.models.get(n);
    const url = `${this.baseUrl}/k${n}_value.json`;
    try {
        const res = await fetch(url, { cache: "force-cache" });
        if(!res.ok) throw new Error(`Model load failed: ${res.status}`);
        const data = await res.json();
        if(!data || !Array.isArray(data.w)) throw new Error(`Bad model format (missing w[])`);
        this.models.set(n, data);
        return data;
    } catch (e) {
        console.warn("ML Model not found, falling back to pure MCTS", e);
        throw e;
    }
  },

  sigmoid(x){
    // stable sigmoid
    if (x >= 0) { const z = Math.exp(-x); return 1/(1+z); }
    const z = Math.exp(x); return z/(1+z);
  },

  features(state){
    const n = state.n;
    const totalEdges = (n*(n-1))/2;
    const remEdges = state.edgesRemaining;
    const deg = state.degrees;

    // degree histogram 0..n-1
    const hist = new Array(n).fill(0);
    let sum=0, sumSq=0, minD=1e9, maxD=-1e9;
    for(let i=0;i<n;i++){
      const d = deg[i];
      hist[d] = (hist[d]||0) + 1;
      sum += d; sumSq += d*d;
      if(d<minD) minD=d; if(d>maxD) maxD=d;
    }
    const avg = sum/n;
    const meanSq = sumSq/n;
    const denom = Math.max(1, n-1);

    const x = [];
    x.push(1.0); // bias
    x.push(remEdges/totalEdges); // edge density
    for(let d=0; d<n; d++) x.push((hist[d]||0)/n); // degree hist
    x.push(avg/denom);
    x.push(minD/denom);
    x.push(maxD/denom);
    x.push((hist[1]||0)/n);
    x.push((hist[2]||0)/n);
    x.push(meanSq/(denom*denom));
    return x; // length = n+8
  },

  predict(state, model){
    const x = this.features(state);
    const w = model.w;
    let s=0;
    const L = Math.min(w.length, x.length);
    for(let i=0;i<L;i++) s += w[i]*x[i];
    return this.sigmoid(s); // prob current player wins
  }
};

/** ---------- Game State ---------- **/
class GraphState {
  constructor(n, activeMask=null, degrees=null, edges=null, edgesRemaining=null){
    this.n = n;
    if(activeMask===null){
      this.edges = [];
      let idx=0;
      for(let u=0;u<n;u++){
        for(let v=u+1;v<n;v++){
          this.edges.push({u,v,idx});
          idx++;
        }
      }
      this.num_edges = idx;
      this.activeMask = (1n<<BigInt(this.num_edges)) - 1n;
      this.degrees = new Int8Array(n).fill(n-1);
      this.edgesRemaining = this.num_edges;
    } else {
      this.edges = edges;
      this.num_edges = edges.length;
      this.activeMask = activeMask;
      this.degrees = new Int8Array(degrees);
      this.edgesRemaining = edgesRemaining;
    }
  }
  clone(){ return new GraphState(this.n, this.activeMask, this.degrees, this.edges, this.edgesRemaining); }
  getHash(turn){ return `n${this.n}_${this.activeMask.toString()}_t${turn}`; }

  getLegalMoves(){
    const moves=[];
    for(let i=0;i<this.num_edges;i++){
      if(((this.activeMask>>BigInt(i)) & 1n)===0n) continue;
      const e=this.edges[i];
      // immediate win exists: remove last incident edge to degree-1 vertex
      if(this.degrees[e.u]===1 || this.degrees[e.v]===1) return [i];
      moves.push(i);
    }
    return moves;
  }

  doMove(i){
    if(((this.activeMask>>BigInt(i)) & 1n)===0n) return false;
    this.activeMask &= ~(1n<<BigInt(i));
    const e=this.edges[i];
    this.degrees[e.u]--; this.degrees[e.v]--;
    this.edgesRemaining--;
    return true;
  }

  isTerminal(){
    for(let i=0;i<this.n;i++) if(this.degrees[i]===0) return true;
    return false;
  }
}

/** ---------- MCTS Node ---------- **/
class MCTSNode {
  constructor(move=null, parent=null, state=null){
    this.move = move;
    this.parent = parent;
    this.children = new Map();
    this.visits = 0;
    this.wins = 0; // "value for player-to-move at this node" aggregated via backprop flip
    this.isExpanded = false;
    this.legalMoves = state ? state.getLegalMoves() : [];
    this.movePriors = null;
  }

  calculatePriors(state){
    const moves = this.legalMoves;
    const priors = {};
    let sum = 0;
    for(const m of moves){
      const e = state.edges[m];
      const score = state.degrees[e.u] + state.degrees[e.v];
      const w = Math.pow(score, 2);
      priors[m] = w;
      sum += w;
    }
    if(sum<=0){
      const p = moves.length ? 1/moves.length : 0;
      for(const m of moves) priors[m] = p;
    } else {
      for(const m of moves) priors[m] /= sum;
    }
    this.movePriors = priors;
  }

  selectChild(cpuct){
    let best=null, bestScore=-Infinity;
    for(const child of this.children.values()){
      const Q = child.visits>0 ? child.wins/child.visits : 0.5;
      const P = (this.movePriors && this.movePriors[child.move]) ? this.movePriors[child.move] : 0;
      const U = cpuct * P * (Math.sqrt(this.visits)/(1+child.visits));
      // We store "wins" from current player's perspective, so higher is better:
      const score = Q + U;
      if(score>bestScore){ bestScore=score; best=child; }
    }
    return best;
  }

  expand(state){
    if(!this.movePriors) this.calculatePriors(state);
    for(const m of this.legalMoves){
      if(!this.children.has(m)){
        this.children.set(m, new MCTSNode(m, this, null));
      }
    }
    this.isExpanded = true;
  }
}

/** ---------- AI Engine ---------- **/
class AIEngine {
  constructor(state, startTurn=0, opts={}){
    this.rootState = state.clone();
    this.currentTurn = startTurn;
    this.root = new MCTSNode(null, null, state);
    this.cpuct = opts.cpuct ?? 1.25;
    this.rolloutSteps = opts.rolloutSteps ?? 120;
  }

  advanceTree(moveIdx){
    // apply move in state first
    this.rootState.doMove(moveIdx);
    this.currentTurn = 1 - this.currentTurn;

    // reuse tree if possible
    if(this.root.children.has(moveIdx)){
      this.root = this.root.children.get(moveIdx);
      this.root.parent = null;
    } else {
      this.root = new MCTSNode(null, null, this.rootState);
    }
  }

  evaluate(state, turn){
    if(state.isTerminal()) return 0.0;

    // 1) ML model (if available)
    const model = MLModels.models.get(state.n);
    if(model){
      return MLModels.predict(state, model);
    }

    // 2) GhostBrain (if available)
    const h = state.getHash(turn);
    const stored = brain.get(h);
    if(stored !== null) return stored;

    // 3) Rollout fallback
    let tmp = state.clone();
    let t = turn;
    for(let steps=0; steps<this.rolloutSteps; steps++){
      const moves = tmp.getLegalMoves();
      if(moves.length===0) return 0.5;

      // if there's an immediate win move, current player wins now
      if(moves.length===1){
        tmp.doMove(moves[0]);
        // the mover caused terminal => mover wins
        return 1.0;
      }

      // heuristic: avoid creating degree-1/2 if possible
      let candidates = moves;
      const safe = moves.filter(m=>{
        const e = tmp.edges[m];
        return tmp.degrees[e.u] > 2 && tmp.degrees[e.v] > 2;
      });
      if(safe.length) candidates = safe;

      const m = candidates[(Math.random()*candidates.length)|0];
      tmp.doMove(m);

      if(tmp.isTerminal()){
        // mover (player who just moved) wins -> that is player t
        return 1.0;
      }
      t = 1 - t;
    }
    return 0.5;
  }

  run(iterBudget, gameId, onProgress){
    return new Promise(resolve=>{
      let it=0;
      const batch=250; // tune for mobile smoothness

      const step = ()=>{
        if(game.id !== gameId) return; // cancelled
        const end = Math.min(it+batch, iterBudget);

        for(; it<end; it++){
          let node = this.root;
          let state = this.rootState.clone();
          let turn = this.currentTurn;

          // SELECTION
          while(node.isExpanded && node.children.size>0){
            const child = node.selectChild(this.cpuct);
            if(!child) break;
            node = child;
            state.doMove(node.move);
            turn = 1 - turn;
          }

          // EXPANSION
          if(!state.isTerminal() && !node.isExpanded){
            node.legalMoves = state.getLegalMoves();
            node.calculatePriors(state);
            node.expand(state);
          }

          // Choose a leaf to evaluate:
          // If we expanded, pick one child to descend (optional). We'll just evaluate current state.
          let v = this.evaluate(state, turn);

          // BACKPROP: flip value each level (because players alternate)
          while(node){
            node.visits++;
            node.wins += v;
            v = 1.0 - v;
            node = node.parent;
          }
        }

        if(onProgress && (it % 1000 === 0 || it === iterBudget)) onProgress(it/iterBudget);

        if(it < iterBudget) requestAnimationFrame(step);
        else resolve(this.root);
      };

      step();
    });
  }

  bestMove(){
    let best=null, maxV=-1;
    for(const child of this.root.children.values()){
      if(child.visits > maxV){ maxV=child.visits; best=child; }
    }
    return best ? best.move : null;
  }
}

/* =========================
   UI + INPUT + RENDER (your existing mobile)
   (kept, only wired to the new engine)
   ========================= */

let game = {
  id: 0,
  n: 9,
  engine: null,
  turn: 0,
  userRole: 0,
  nodes: [],
  selectedEdge: -1,
  history: [],
  gameOver: false
};

function setUI(state){
  const statusText = document.getElementById('status-text');
  const hintText = document.getElementById('hint-text');
  const turnInd = document.getElementById('turn-indicator');
  const thinkLine = document.getElementById('thinking-line');

  if(state === 'thinking'){
    statusText.innerText = "AI THINKING";
    statusText.className = "text-xs font-bold uppercase tracking-widest text-purple-400";
    hintText.innerText = "Please wait...";
    turnInd.className = "w-3 h-3 rounded-full bg-purple-500 animate-pulse";
    thinkLine.style.opacity = 1;
  } else if(state === 'player'){
    statusText.innerText = "YOUR TURN";
    statusText.className = "text-xs font-bold uppercase tracking-widest text-emerald-400";
    hintText.innerText = "Double tap edge to cut";
    turnInd.className = "w-3 h-3 rounded-full bg-emerald-500 animate-pulse";
    thinkLine.style.opacity = 0;
  } else {
    thinkLine.style.opacity = 0;
  }
}

function resetUI(){
  document.getElementById('message-overlay').classList.remove('visible');
}

function initGame(n, role){
  game.id++;
  game.n = n;
  game.userRole = role;
  game.turn = 0;
  game.selectedEdge = -1;
  game.history = [];
  game.gameOver = false;

  // node layout in world coords
  game.nodes = [];
  const r = 400;
  for(let i=0;i<n;i++){
    const ang = (i * 2 * Math.PI / n) - Math.PI/2;
    game.nodes.push({ x: Math.cos(ang)*r, y: Math.sin(ang)*r });
  }

  // engine
  const startState = new GraphState(n);
  game.engine = new AIEngine(startState, 0, { cpuct: 1.25, rolloutSteps: 120 });

  Camera.reset();
  resetUI();

  // load ML model (optional)
  MLModels.loadForN(n).then(()=>{
    // optional: show in hint
    if(document.getElementById('hint-text')) document.getElementById('hint-text').innerText = "ML Brain Active ‚Ä¢ Double tap edge";
  }).catch(()=>{
    // ignore, fallback logic still works
  });

  // if AI starts
  if(game.turn !== game.userRole) setTimeout(()=>aiMove(game.id), 350);
  else setUI('player');
}

async function aiMove(sessionId){
  if(game.gameOver) return;
  if(sessionId !== game.id) return;

  setUI('thinking');

  // mobile: iteration budget. Increase to get stronger:
  const ITERS = 25000; // try 10k, 25k, 50k depending on phone
  await game.engine.run(ITERS, sessionId, (p)=>{
    // optional: could animate thinking-line intensity; keep minimal
  });
  if(sessionId !== game.id || game.gameOver) return;

  const move = game.engine.bestMove();
  if(move === null){
    const moves = game.engine.rootState.getLegalMoves();
    if(moves.length) applyMove(moves[0]);
    return;
  }
  applyMove(move);
}

function applyMove(idx){
  if(game.gameOver) return;

  // record for ghostbrain training (state BEFORE move, player-to-move = game.turn)
  game.history.push({ h: game.engine.rootState.getHash(game.turn), p: game.turn });

  // visual flash for the move just made (game.turn is still the mover here)
  Renderer.triggerFlash(idx);

  // make move
  game.engine.advanceTree(idx);
  game.selectedEdge = -1;

  // check terminal: the mover (game.turn) just won
  if(game.engine.rootState.isTerminal()){
    endGame(game.turn);
    return;
  }

  // next turn
  game.turn = 1 - game.turn;

  if(game.turn !== game.userRole){
    setTimeout(()=>aiMove(game.id), 200);
  } else {
    setUI('player');
  }
}

function endGame(winner){
  game.gameOver = true;

  // update ghost brain: value = 1 if player-to-move at that hash eventually wins
  for(const step of game.history){
    const z = (step.p === winner) ? 1.0 : 0.0;
    brain.update(step.h, z);
  }
  brain.save();

  const isWin = winner === game.userRole;
  document.getElementById('msg-title').innerText = isWin ? "VICTORY" : "DEFEAT";
  document.getElementById('msg-title').className = isWin
    ? "text-4xl font-black text-emerald-400 mb-2"
    : "text-4xl font-black text-red-500 mb-2";
  document.getElementById('msg-sub').innerText = isWin ? "You are the Edge Master." : "The AI isolated a node.";
  document.getElementById('msg-icon').innerText = isWin ? "üèÜ" : "üíÄ";
  document.getElementById('message-overlay').classList.add('visible');
  setUI('ended');
}

/** ---------- Camera + Input (yours, small wiring changes) ---------- **/
const Camera = {
  x: 0, y: 0, zoom: 1,
  minZoom: 0.5, maxZoom: 3,
  reset(){
    this.x = window.innerWidth/2;
    this.y = window.innerHeight/2;
    this.zoom = Math.min(window.innerWidth, window.innerHeight)/1000;
  },
  toWorld(sx, sy){ return { x:(sx-this.x)/this.zoom, y:(sy-this.y)/this.zoom }; },
  toScreen(wx, wy){ return { x: wx*this.zoom + this.x, y: wy*this.zoom + this.y }; }
};

function distToSegment(p, v, w){
  const l2 = (v.x-w.x)**2 + (v.y-w.y)**2;
  if(l2===0) return Math.hypot(p.x-v.x, p.y-v.y);
  let t = ((p.x-v.x)*(w.x-v.x)+(p.y-v.y)*(w.y-v.y))/l2;
  t = Math.max(0, Math.min(1, t));
  return Math.hypot(p.x-(v.x+t*(w.x-v.x)), p.y-(v.y+t*(w.y-v.y)));
}

const Input = {
  pointers: new Map(),
  dist: 0,

  init(){
    const c = document.getElementById('gameCanvas');
    c.addEventListener('pointerdown', this.down.bind(this));
    c.addEventListener('pointermove', this.move.bind(this));
    c.addEventListener('pointerup', this.up.bind(this));
    c.addEventListener('pointercancel', this.up.bind(this));
    c.addEventListener('wheel', this.wheel.bind(this), { passive:false });
  },

  getDist(p1,p2){ return Math.hypot(p1.clientX-p2.clientX, p1.clientY-p2.clientY); },
  getCenter(){
    let x=0,y=0,c=0;
    for(const p of this.pointers.values()){ x+=p.clientX; y+=p.clientY; c++; }
    return {x:x/c, y:y/c};
  },

  down(e){
    this.pointers.set(e.pointerId, e);
    if(this.pointers.size===2){
      const arr=[...this.pointers.values()];
      this.dist = this.getDist(arr[0], arr[1]);
    }
  },

  move(e){
    if(!this.pointers.has(e.pointerId)) return;
    const prev = this.pointers.get(e.pointerId);

    if(this.pointers.size===1){
      Camera.x += e.clientX - prev.clientX;
      Camera.y += e.clientY - prev.clientY;
    } else if(this.pointers.size===2){
      this.pointers.set(e.pointerId, e);
      const arr=[...this.pointers.values()];
      const newDist = this.getDist(arr[0], arr[1]);
      const center = this.getCenter();
      const factor = newDist / this.dist;

      const newZoom = Math.min(Camera.maxZoom, Math.max(Camera.minZoom, Camera.zoom * factor));

      const wx = (center.x - Camera.x)/Camera.zoom;
      const wy = (center.y - Camera.y)/Camera.zoom;

      Camera.x = center.x - wx*newZoom;
      Camera.y = center.y - wy*newZoom;
      Camera.zoom = newZoom;

      this.dist = newDist;
    }

    this.pointers.set(e.pointerId, e);
  },

  up(e){
    if(!this.pointers.has(e.pointerId)) return;

    // tap detection: only if it's player's turn and game is live
    if(this.pointers.size===1 && !game.gameOver && game.turn===game.userRole){
      const downEv = this.pointers.get(e.pointerId);
      const moveAmt = Math.hypot(e.clientX - downEv.clientX, e.clientY - downEv.clientY);
      if(moveAmt < 10) this.handleTap(e.clientX, e.clientY);
    }

    this.pointers.delete(e.pointerId);
  },

  wheel(e){
    e.preventDefault();
    const factor = e.deltaY>0 ? 0.9 : 1.1;
    const wx = (e.clientX - Camera.x)/Camera.zoom;
    const wy = (e.clientY - Camera.y)/Camera.zoom;
    Camera.zoom = Math.min(Camera.maxZoom, Math.max(Camera.minZoom, Camera.zoom*factor));
    Camera.x = e.clientX - wx*Camera.zoom;
    Camera.y = e.clientY - wy*Camera.zoom;
  },

  handleTap(sx, sy){
    if(!game.engine) return;
    const w = Camera.toWorld(sx, sy);
    const s = game.engine.rootState;

    let best=-1;
    let minD = 40/Camera.zoom;
    for(let i=0;i<s.num_edges;i++){
      if(((s.activeMask>>BigInt(i)) & 1n)===0n) continue;
      const u = game.nodes[s.edges[i].u];
      const v = game.nodes[s.edges[i].v];
      const d = distToSegment(w, u, v);
      if(d < minD){ minD=d; best=i; }
    }

    if(best !== -1){
      // double tap selects then executes
      if(game.selectedEdge === best){
        applyMove(best);
      } else {
        game.selectedEdge = best;
        setTimeout(()=>{ if(game.selectedEdge===best) game.selectedEdge=-1; }, 1600);
      }
    } else {
      game.selectedEdge = -1;
    }
  }
};

/** ---------- Renderer (yours, minimal dependency on game.engine.rootState) ---------- **/
const Renderer = {
  canvas:null, ctx:null, flash:null,

  init(){
    this.canvas = document.getElementById('gameCanvas');
    this.ctx = this.canvas.getContext('2d');
    this.resize();
    this.loop();
  },

  resize(){
    if (!this.canvas) return;
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
  },

  triggerFlash(idx){
    this.flash = {
      idx,
      time: Date.now(),
      color: (game.turn === 0) ? '#a855f7' : '#10b981' // Alice purple, Bob green
    };
  },

  loop(){
    if(!this.ctx || !this.canvas) return;
    const ctx=this.ctx;
    ctx.fillStyle = (game.userRole===0) ? '#0f172a' : '#022c22';
    ctx.fillRect(0,0,this.canvas.width,this.canvas.height);

    if(!game.engine){
      requestAnimationFrame(()=>this.loop());
      return;
    }

    const s = game.engine.rootState;

    ctx.save();
    ctx.translate(Camera.x, Camera.y);
    ctx.scale(Camera.zoom, Camera.zoom);

    // edges
    ctx.lineCap = "round";
    for(let i=0;i<s.num_edges;i++){
      if(((s.activeMask>>BigInt(i)) & 1n)===0n) continue;
      const e=s.edges[i];
      const p1=game.nodes[e.u], p2=game.nodes[e.v];

      ctx.beginPath();
      ctx.moveTo(p1.x,p1.y);
      ctx.lineTo(p2.x,p2.y);

      if(i===game.selectedEdge){
        ctx.lineWidth = 12;
        ctx.strokeStyle = '#f43f5e';
        ctx.shadowColor = '#f43f5e';
        ctx.shadowBlur = 15;
      } else {
        ctx.lineWidth = 6;
        ctx.strokeStyle = 'rgba(255,255,255,0.9)';
        ctx.shadowBlur = 0;
      }
      ctx.stroke();
    }

    // flash last move
    if(this.flash && (Date.now()-this.flash.time < 500)){
      const edgeDef = s.edges[this.flash.idx];
      if(edgeDef){
        const p1=game.nodes[edgeDef.u], p2=game.nodes[edgeDef.v];
        ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y);
        ctx.lineWidth = 6;
        ctx.strokeStyle = this.flash.color;
        ctx.globalAlpha = 1 - (Date.now()-this.flash.time)/500;
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
    }

    // nodes
    ctx.shadowBlur = 0;
    for(let i=0;i<game.n;i++){
      const p=game.nodes[i];
      const d=s.degrees[i];
      ctx.beginPath();
      ctx.arc(p.x,p.y,25,0,Math.PI*2);

      if(d===1) ctx.fillStyle='#ef4444';
      else if(d===2) ctx.fillStyle='#eab308';
      else ctx.fillStyle='#3b82f6';

      ctx.fill();
      ctx.strokeStyle='#1e293b';
      ctx.lineWidth=4;
      ctx.stroke();

      ctx.fillStyle='#fff';
      ctx.font='bold 16px Inter';
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.fillText(d, p.x, p.y);
    }

    ctx.restore();
    requestAnimationFrame(()=>this.loop());
  }
};

/** ---------- Settings/UI Buttons (yours) ---------- **/
function toggleSettings(){
  const m=document.getElementById('settings-modal');
  const b=document.getElementById('modal-backdrop');
  const active = m.classList.contains('active');
  if(active){ m.classList.remove('active'); b.classList.remove('active'); }
  else { m.classList.add('active'); b.classList.add('active'); }
}
window.toggleSettings = toggleSettings;

function updateN(val){ document.getElementById('n-display').innerText = val; }
window.updateN = updateN;

function startGameAs(role){
  document.getElementById('selection-screen').style.opacity = 0;
  setTimeout(()=>{
    document.getElementById('selection-screen').style.display='none';
    initGame(parseInt(document.getElementById('nRange').value,10), role);
  }, 350);
}
window.startGameAs = startGameAs;

function changePlayer(){
  toggleSettings();
  document.getElementById('selection-screen').style.display='flex';
  setTimeout(()=>document.getElementById('selection-screen').style.opacity = 1, 50);
}
window.changePlayer = changePlayer;

function restartGame(){
  document.getElementById('message-overlay').classList.remove('visible');
  document.getElementById('settings-modal').classList.remove('active');
  document.getElementById('modal-backdrop').classList.remove('active');
  initGame(parseInt(document.getElementById('nRange').value,10), game.userRole);
}
window.restartGame = restartGame;

/** ---------- Boot ---------- **/
window.addEventListener('resize', ()=>Renderer.resize());
Renderer.init();
Input.init();
</script>
</body>
</html>
